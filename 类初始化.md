## 类的初始化过程
加载-验证-准备-解析-初始化-使用-卸载

### 加载
1. 根据类的全限定名来加载类的二进制流（从网络，zip，动态代理获取）
2. 讲二进制流所代表的静态存储结构转化为方法区运行时的类型数据
3. 在内存中生成代表这个类的java.lang.Class对象，作为方法区这个类的访问入口

### 验证
1. 文件格式校验-----保证输入的字节流能正确在方法区解析并存储
2. 元数据验证
  * 该类是否有父类（除了Object）
  * 是否继承了final类
  * 字段、方法是否与父类矛盾
  * 如果不是抽象类，是否实现了接口或抽象方法
  * 。。。
3. 字节码验证
4. 符号引用验证-------发生在虚拟机讲符号引用转化为直接引用的时候，转化动作在解析阶段进行
   符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验
   * 符号引用中通过字符串描述的类名是否可以找到对应的类
   * 在指定类中是否存在符合方法的字段描述符和简单名称所描述的字段和方法
   * 符号应用中的类、字段、方法是否可被当前类访问（private，public，protected，default）

验证阶段是非常重要但不是必要的阶段，如果代码被全部验证并反复使用，确保没问题可以使用-XVerify:none关闭校验，缩短虚拟机加载时间

### 准备
为类变量（static）分配内存并初始化值，这些变量的内存都在方法区中分配

### 解析
将常量池中符号引用替换为直接引用

* 符号引用：用一组符号来描述所引用的目标，符号引用与虚拟机实现的内存布局无关，加载的目标不一定已经加载到内存中。
* 直接引用：直接引用是可以直接指向目标的指针、相对偏移量或能间接定位到目标的句柄。直接引用和虚拟机的内存布局是相关的，同一类目标在不同虚拟机上翻译出来的直接引用一般不同，如果有了直接引用，那么目标一定已经被加载到内存中。

解析主要针对类或接口、类方法、字段、接口方法、方法类型、方法句柄和调用点限定符7类符号引用

#### 方法引用：
invokestatic：静态方法
invokeinterface：调用接口方法，运行时确定调用对象
invokespecial：父类方法，实例构造器，私有方法
invokevirtual：虚方法
invokedynamic：运行时动态解析出方法引用（动态代理...）

只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合条件的是静态方法，父类方法，私有方法，实例构造器，它们在类加载的时候可以直接把符号引用解析为该方法的直接引用，这些方法称为非虚方法，其他的都是虚方法（final方法除外）



前四个方法是jvm内部的，invokedynamic的分派指令是用户设定的引导方法决定的



## 初始化
执行类的构造方法clinit，父类的clinit先执行




